// Generated by CoffeeScript 1.6.3
var DownloadManager, ExclusiveTimer, SAMPLE_IDS, SAMPLE_NAMES, TextAreaChangeTracker, capitalizeName, createMergedTable, i, idsToList, process, scantronSummaryToList, showSampleData, showSampleID,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

window.onload = function() {
  var dataAreaTracker, idorderAreaTracker, timer;
  $('#process').click(process);
  $('#idsample').click(showSampleID);
  $('#datasample').click(showSampleData);
  $('#downloadcsv').click(function() {
    var data;
    data = $('#result').val();
    window.downloadManager = new DownloadManager('grades.csv', data, 'text/csv');
    return downloadManager.download();
  });
  timer = new ExclusiveTimer;
  dataAreaTracker = new TextAreaChangeTracker('#data');
  idorderAreaTracker = new TextAreaChangeTracker('#idorder');
  dataAreaTracker.change(function() {
    return timer.setTimeout(process, 250);
  });
  idorderAreaTracker.change(function() {
    return timer.setTimeout(process, 250);
  });
  return process();
};

SAMPLE_IDS = (function() {
  var _i, _results;
  _results = [];
  for (i = _i = 0; _i < 20; i = ++_i) {
    _results.push("V00" + Math.random().toFixed(6).slice(-6));
  }
  return _results;
})();

SAMPLE_NAMES = ["Rowden Shaun", "Wetherbee Janay", "Kimmell Kala", "Dimmick Rikki", "Storment Anitra", "Karp Cassie", "Mccallion Kisha", "Sable Elijah", "Svoboda Freeman", "Reddick Trista", "Sproull Deloras", "Paisley Kerry", "Furby Weston", "Reyes Shiela", "Ballou Clement", "Woolum Gala", "Desilets Stacey", "Rickel Alethea", "Royston Peg", "Marlar Annamaria"];

showSampleID = function() {
  $('#idorder').val(SAMPLE_IDS.join('\n'));
  return $('#idorder').change();
};

showSampleData = function() {
  var ids, lines, longNames, n, paddWithSpace, ret, scores, sliceAmount, _i;
  paddWithSpace = function(s, n) {
    return (s + "                    ").slice(0, n);
  };
  longNames = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = SAMPLE_NAMES.length; _i < _len; _i++) {
      n = SAMPLE_NAMES[_i];
      _results.push(paddWithSpace(n.toUpperCase(), 20));
    }
    return _results;
  })();
  ids = SAMPLE_IDS.slice();
  ids.sort();
  scores = (function() {
    var _i, _results;
    _results = [];
    for (i = _i = 0; _i < 20; i = ++_i) {
      _results.push(Math.round(Math.random() * 20));
    }
    return _results;
  })();
  lines = [];
  for (i = _i = 0; _i < 10; i = ++_i) {
    ret = '';
    ret += longNames[i];
    sliceAmount = Math.random() < .2 ? -5 : -6;
    ret += paddWithSpace(ids[i].slice(sliceAmount), 11);
    ret += paddWithSpace(scores[i], 5);
    ret += scores[i] * 5;
    lines.push(ret);
  }
  lines.sort();
  $('#data').val(lines.join('\n'));
  return $('#data').change();
};

capitalizeName = function(name) {
  var s;
  name = name.toLowerCase().split(/\W+/);
  return ((function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = name.length; _i < _len; _i++) {
      s = name[_i];
      _results.push(s.charAt(0).toUpperCase() + s.slice(1));
    }
    return _results;
  })()).join(' ');
};

createMergedTable = function(idList, data) {
  var duplicateIdHash, errors, id, idHash, l, ret, s, _i, _j, _k, _len, _len1, _len2;
  if (idList == null) {
    idList = [];
  }
  errors = [];
  idHash = {};
  duplicateIdHash = {};
  for (_i = 0, _len = data.length; _i < _len; _i++) {
    s = data[_i];
    if (idHash[s.id] == null) {
      idHash[s.id] = s;
    } else {
      duplicateIdHash[s.id] = duplicateIdHash[s.id] || [idHash[s.id]];
      duplicateIdHash[s.id].push(s);
    }
  }
  for (id in duplicateIdHash) {
    l = duplicateIdHash[id];
    delete idHash[id];
    for (_j = 0, _len1 = l.length; _j < _len1; _j++) {
      s = l[_j];
      errors.push({
        originalLine: s.originalLine,
        included: false,
        reason: "Parsed ID 'V00" + s.id + "' appeared multiple times"
      });
    }
  }
  ret = [];
  if (idList.length === 0) {
    for (id in idHash) {
      s = idHash[id];
      ret.push(s);
    }
  } else {
    for (_k = 0, _len2 = idList.length; _k < _len2; _k++) {
      id = idList[_k];
      ret.push(idHash[id] || {
        id: id
      });
      if (idHash[id] != null) {
        idHash[id].included = true;
      }
    }
    for (id in idHash) {
      s = idHash[id];
      if (!s.included) {
        errors.push({
          originalLine: s.originalLine,
          included: false,
          reason: "No matching ID found in ID List"
        });
      }
    }
  }
  return {
    lines: ret,
    errors: errors
  };
};

idsToList = function(str) {
  var ids, s;
  ids = str.split(/\D+/);
  ids = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = ids.length; _i < _len; _i++) {
      s = ids[_i];
      if (s.match(/\d{6}$/)) {
        _results.push(s.slice(-6));
      }
    }
    return _results;
  })();
  return ids;
};

process = function() {
  var csv, err, errors, idList, mergingErrors, outputList, processingErrors, s, scantronData, tbody, _i, _len, _ref, _ref1;
  idList = idsToList($('#idorder')[0].value);
  _ref = scantronSummaryToList($('#data')[0].value), scantronData = _ref.lines, processingErrors = _ref.errors;
  _ref1 = createMergedTable(idList, scantronData), outputList = _ref1.lines, mergingErrors = _ref1.errors;
  errors = processingErrors.concat(mergingErrors);
  csv = ((function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = outputList.length; _i < _len; _i++) {
      s = outputList[_i];
      _results.push("V00" + s.id + "," + (s.score || '') + ",\"" + (s.name || '') + "\"");
    }
    return _results;
  })()).join('\n');
  $('#result')[0].value = csv;
  tbody = $('#errors-table tbody');
  tbody.empty();
  for (_i = 0, _len = errors.length; _i < _len; _i++) {
    err = errors[_i];
    tbody.append("<tr>\n    <td class='data'>" + err.originalLine + "</td>\n    <td class='included-" + (!!err.included) + "'>" + (err.included ? 'Yes' : 'No') + "</td>\n    <td class='reason'>" + err.reason + "</td>\n</tr>");
  }
  if (errors.length > 0) {
    $('#error-area').show();
  } else {
    $('#error-area').hide();
  }
};

scantronSummaryToList = function(s) {
  var e, erroniousLines, l, lines, processLine, _i, _len, _ref, _ref1;
  processLine = function(l) {
    var e, id, idIndex, oldID, originalLine, ret, str, _i, _len;
    originalLine = l;
    l = l.replace(/([a-zA-Z])(\d)/g, "$1 $2").split(/\s+/);
    idIndex = null;
    for (i = _i = 0, _len = l.length; _i < _len; i = ++_i) {
      str = l[i];
      if (str.match(/\d{6}$/)) {
        idIndex = i;
        break;
      }
    }
    if ((idIndex == null) || l[idIndex].length < 6) {
      e = new Error("Could not find id in \'" + l + "'");
      e.originalLine = originalLine;
      throw e;
    }
    ret = {
      originalLine: originalLine
    };
    id = l[idIndex];
    if (id.length > 6) {
      oldID = id;
      ret.badBubbling = true;
      if (id.charAt(0) === '0') {
        id = id.slice(-6);
      } else {
        id = id.slice(0, 6);
      }
    }
    ret.id = id;
    ret.score = l[idIndex + 1];
    ret.name = capitalizeName(l.slice(0, idIndex).join(' '));
    ret.percent = l[idIndex + 2];
    return ret;
  };
  lines = [];
  erroniousLines = [];
  _ref = s.split(/\n/);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    l = _ref[_i];
    if (l.match(/SUMMARY SHEET/) || l.match(/SCORE PERCENT/)) {
      continue;
    }
    try {
      lines.push(processLine(l));
    } catch (_error) {
      e = _error;
      if ((_ref1 = e.originalLine) != null ? _ref1.match(/\w/) : void 0) {
        erroniousLines.push({
          originalLine: e.originalLine,
          reason: 'Could not parse student ID'
        });
      }
    }
  }
  return {
    lines: lines,
    errors: erroniousLines
  };
};

/*
# ExclusiveTimer keeps a queue of all timeout
# callbacks, but only issues the most recent one.
# That is, if another callback request is added before the
# timer on the previous one runs out, only the new one is executed
# (when it's time has elapased) and the previous one is ignored.
*/


ExclusiveTimer = (function() {
  function ExclusiveTimer() {
    this.queue = [];
  }

  ExclusiveTimer.prototype.setTimeout = function(callback, delay) {
    var c, doCallback, myIndex, _i, _len, _ref,
      _this = this;
    _ref = this.queue;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      c.execute = false;
    }
    myIndex = this.queue.length;
    this.queue.push({
      callback: callback,
      execute: true
    });
    doCallback = function() {
      var _ref1;
      if ((_ref1 = _this.queue[myIndex]) != null ? _ref1.execute : void 0) {
        _this.queue[myIndex].callback();
        return _this.queue.length = 0;
      }
    };
    return window.setTimeout(doCallback, delay);
  };

  return ExclusiveTimer;

})();

/*
# Keep track of all changes to a particular textarea
# including ones that may happen on keyup, keydown, blur,
# etc.
*/


TextAreaChangeTracker = (function() {
  function TextAreaChangeTracker(textarea) {
    var _this = this;
    this.textarea = textarea;
    this._triggerIfChanged = __bind(this._triggerIfChanged, this);
    this.textarea = $(this.textarea);
    this.value = this.textarea.val();
    this.onchangeCallbacks = [];
    this.textarea.change(function() {
      return window.setTimeout(_this._triggerIfChanged, 100);
    });
    this.textarea.keydown(function() {
      return window.setTimeout(_this._triggerIfChanged, 100);
    });
    this.textarea.keypress(function() {
      return window.setTimeout(_this._triggerIfChanged, 100);
    });
    this.textarea.blur(function() {
      return window.setTimeout(_this._triggerIfChanged, 100);
    });
  }

  TextAreaChangeTracker.prototype._triggerIfChanged = function() {
    var c, newVal, _i, _len, _ref, _results;
    newVal = this.textarea[0].value;
    if (newVal !== this.value) {
      this.value = newVal;
      _ref = this.onchangeCallbacks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(c());
      }
      return _results;
    }
  };

  TextAreaChangeTracker.prototype.change = function(callback) {
    return this.onchangeCallbacks.push(callback);
  };

  return TextAreaChangeTracker;

})();

/*
# Various methods of downloading data to the users compuer so they can save it.
# Initially DownloadManager.download will try to bounce off download.php,
# a server-side script that sends the data it receives back with approprate
# headers. If this fails, it will try to use the blob API to and the
# 'download' attribute of an anchor to download the file with a suggested file name.
# If this fails, a dataURI is used.
*/


DownloadManager = (function() {
  DownloadManager.prototype.DOWNLOAD_SCRIPT = 'download.php';

  function DownloadManager(filename, data, mimetype) {
    this.filename = filename;
    this.data = data;
    this.mimetype = mimetype != null ? mimetype : 'application/octet-stream';
    this.downloadDataUriBased = __bind(this.downloadDataUriBased, this);
    this.downloadBlobBased = __bind(this.downloadBlobBased, this);
    this.downloadServerBased = __bind(this.downloadServerBased, this);
    this.testDataUriAvailability = __bind(this.testDataUriAvailability, this);
    this.testBlobAvailability = __bind(this.testBlobAvailability, this);
    this.testServerAvailability = __bind(this.testServerAvailability, this);
    this.download = __bind(this.download, this);
    this.downloadMethodAvailable = {
      serverBased: null,
      blobBased: null,
      dataUriBased: null
    };
  }

  DownloadManager.prototype.download = function() {
    if (this.downloadMethodAvailable.serverBased === null) {
      this.testServerAvailability(this.download);
      return;
    }
    if (this.downloadMethodAvailable.serverBased === true) {
      this.downloadServerBased();
      return;
    }
    if (this.downloadMethodAvailable.blobBased === null) {
      this.testBlobAvailability(this.download);
      return;
    }
    if (this.downloadMethodAvailable.blobBased === true) {
      this.downloadBlobBased();
      return;
    }
    if (this.downloadMethodAvailable.dataUriBased === null) {
      this.testDataUriAvailability(this.download);
      return;
    }
    if (this.downloadMethodAvailable.dataUriBased === true) {
      this.downloadDataUriBased();
    }
  };

  DownloadManager.prototype.testServerAvailability = function(callback) {
    var _this = this;
    if (callback == null) {
      callback = function() {};
    }
    return $.ajax({
      url: this.DOWNLOAD_SCRIPT,
      dataType: 'text',
      success: function(data, status, response) {
        if (response.getResponseHeader('Content-Description') === 'File Transfer') {
          _this.downloadMethodAvailable.serverBased = true;
        } else {
          _this.downloadMethodAvailable.serverBased = false;
        }
        return callback.call(_this);
      },
      error: function(data, status, response) {
        _this.downloadMethodAvailable.serverBased = false;
        return callback.call(_this);
      }
    });
  };

  DownloadManager.prototype.testBlobAvailability = function(callback) {
    if (callback == null) {
      callback = function() {};
    }
    if ((window.webkitURL || window.URL) && (window.Blob || window.MozBlobBuilder || window.WebKitBlobBuilder)) {
      this.downloadMethodAvailable.blobBased = true;
    } else {
      this.downloadMethodAvailable.blobBased = true;
    }
    return callback.call(this);
  };

  DownloadManager.prototype.testDataUriAvailability = function(callback) {
    if (callback == null) {
      callback = function() {};
    }
    this.downloadMethodAvailable.dataUriBased = true;
    return callback.call(this);
  };

  DownloadManager.prototype.downloadServerBased = function() {
    var form, input1, input2, input3;
    input1 = $('<input type="hidden"></input>').attr({
      name: 'filename',
      value: this.filename
    });
    input2 = $('<input type="hidden"></input>').attr({
      name: 'data',
      value: btoa(this.data)
    });
    input3 = $('<input type="hidden"></input>').attr({
      name: 'mimetype',
      value: this.mimetype
    });
    form = $('<form action="' + this.DOWNLOAD_SCRIPT + '" method="post" target="downloads_iframe"></form>');
    form.append(input1).append(input2).append(input3);
    return form.appendTo(document.body).submit().remove();
  };

  DownloadManager.prototype.downloadBlobBased = function(errorCallback) {
    var bb, blob, buf, bufView, downloadLink, e, url, _i, _ref;
    if (errorCallback == null) {
      errorCallback = this.download;
    }
    try {
      buf = new ArrayBuffer(this.data.length);
      bufView = new Uint8Array(buf);
      for (i = _i = 0, _ref = this.data.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        bufView[i] = this.data.charCodeAt(i) & 0xff;
      }
      try {
        blob = new Blob(buf, {
          type: 'application/octet-stream'
        });
      } catch (_error) {
        e = _error;
        bb = new (window.WebKitBlobBuilder || window.MozBlobBuilder);
        bb.append(buf);
        blob = bb.getBlob('application/octet-stream');
      }
      url = (window.webkitURL || window.URL).createObjectURL(blob);
      downloadLink = $('<a></a>').attr({
        href: url,
        download: this.filename
      });
      $(document.body).append(downloadLink);
      downloadLink[0].click();
      return downloadLink.remove();
    } catch (_error) {
      e = _error;
      this.downloadMethodAvailable.blobBased = false;
      return errorCallback.call(this);
    }
  };

  DownloadManager.prototype.downloadDataUriBased = function() {
    return document.location.href = "data:application/octet-stream;base64," + btoa(this.data);
  };

  return DownloadManager;

})();
